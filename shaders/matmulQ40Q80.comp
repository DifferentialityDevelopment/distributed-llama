#version 450
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

struct BLOCK_Q40
{
    uint16_t d;
    uint8_t qs[16]; // 16 bytes to store 32 nibbles
};

struct BLOCK_Q80
{
    uint16_t d;
    int8_t qs[32]; // 32 bytes to store 32 int8 values
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly buffer WeightsBuffer {
    BLOCK_Q40 weights[];
};

layout(std430, set = 0, binding = 1) readonly buffer InputBuffer {
    BLOCK_Q80 inputs[];
};

layout(std430, set = 0, binding = 2) writeonly buffer OutputBuffer {
    float outputs[];
};

layout(std430, set = 0, binding = 3) readonly buffer ConversionBuffer {
    float F16_to_F32[65536]; //lookup table for float16 to float32 using uint16_t as index
};

// Uniform buffer for matrix information
layout(std430, set = 1, binding = 0) uniform MatMulInfo {
    int n;  // number of elements to process
    int ds; // start index for output
    int de; // end index for output
};

float convertF16ToF32(uint16_t value) {
    return F16_to_F32[int(value)];
}

shared uint totalGid;

void main() {
    const uint gid = gl_GlobalInvocationID.x; // Global Thread ID
    const uint dimSize = de - ds;

    outputs[gid] = 0.0f;
    barrier();

    float acc = 0.0f;
    const uint numberOfBlocks = n / 32;

    for (uint j = 0; j < numberOfBlocks; ++j) {
        uint blockIndexWeight = gid * dimSize + j;
        float wScale = convertF16ToF32(weights[blockIndexWeight].d);
        float iScale = convertF16ToF32(inputs[j].d);
        //float combinedScale = convertF16ToF32(weights[blockIndexWeight].d) * convertF16ToF32(inputs[j].d);

        uint8_t qsWeight[16] = weights[blockIndexWeight].qs;
        int bx[32];
        for (int i = 0; i < 16; i++) {
            bx[2 * i] = int(qsWeight[i] & 0x0F) - 8;
            bx[2 * i + 1] = int((qsWeight[i] >> 4) & 0x0F) - 8;
        }

        int8_t by[32] = inputs[j].qs;
        //float q = 0.0f;
        for (int i = 0; i < 32; i++) {
            //q += bx[i] * by[i];
            acc += (bx[i] * wScale) * (by[i] * iScale);
        }
        //acc += float(q * combinedScale);
    }

    barrier();
    outputs[gid] = acc;
    memoryBarrier();
}