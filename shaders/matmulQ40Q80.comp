#version 450
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

struct BLOCK_Q40
{
    float16_t d;
    uint8_t qs[16];
};
struct BLOCK_Q80
{
    float16_t d;
    uint8_t qs[32];
};

#define WEIGHT_DATA BLOCK_Q40
#define INPUT_DATA BLOCK_Q80
#define FLOAT_TYPE float16_t
#define D_TYPE float16_t
#define QUANT_40 32
#define QUANT_80 32
#define QUANT_R 2

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Buffer for weights data
layout(set = 0, binding = 0) readonly buffer WeightsBuffer {
    WEIGHT_DATA weightsBuffer[];
};

// Buffer for input data
layout(set = 0, binding = 1) readonly buffer InputBuffer {
    INPUT_DATA inputBuffer[];
};

// Buffer for output data
layout(set = 0, binding = 2) writeonly buffer OutputBuffer {
    float outputBuffer[];
};

// Uniform buffer for matrix information
layout(set = 1, binding = 0) uniform MatMulInfo {
    int n;
    int ds;
    int de;
};

const int QK40 = 32;
const int blocksPerRow = 8;
const int k = QK40 * blocksPerRow;

shared FLOAT_TYPE tmp[QK40];

vec2 dequantizeQ40Weight(uint ib, uint iqs, uint a_offset) {
    const float d = float(weightsBuffer[a_offset + ib].d);
    const uint quantizedValue = weightsBuffer[a_offset + ib].qs[iqs / 2]; // Access two 4-bit values per byte
    const uint shiftAmount = (iqs % 2) * 4; // Shift for high or low nibble
    const uint quantizedSubValue = (quantizedValue >> shiftAmount) & 0xF; // Extract 4 bits
    float dequantizedValue = (float(quantizedSubValue) - 8.0f) * d; // Subtract offset and scale
    return vec2(dequantizedValue, dequantizedValue);
}

vec2 dequantizeQ80Input(uint ib, uint iqs, uint a_offset) {
    const float d = float(inputBuffer[a_offset + ib].d);
    const uint quantizedValue = inputBuffer[a_offset + ib].qs[iqs]; // Directly access 8-bit value
    float dequantizedValue = (float(quantizedValue) - 128.0f) * d; // Subtract offset and scale
    return vec2(dequantizedValue, dequantizedValue);
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    const uint tid = gl_LocalInvocationID.x % QK40;
    const uint ncols = de - ds;

    const uint row = gl_WorkGroupID.x;
    const uint y_offset = QUANT_R == 1 ? 1 : QUANT_40 / 2;
    const uint d_offset = row; // Use row index for output buffer

    tmp[tid] = FLOAT_TYPE(0.0f);

    for (uint i = 0; i < ncols / QK40; i += 2) {
        const uint col = i * QK40 + 2 * tid;
        const uint ib = (row * ncols + col) / QUANT_40 / 2;
        const uint iqs = (col % QUANT_40 / 2) / QUANT_R;
        vec2 wv = dequantizeQ40Weight(ib, iqs, 0);
        vec2 iv = dequantizeQ80Input(ib, iqs, 0);

        tmp[tid] += FLOAT_TYPE(wv.x) * FLOAT_TYPE(iv.y) + FLOAT_TYPE(wv.y) * FLOAT_TYPE(iv.x);
    }

    barrier();

    for (uint s = QK40 / 2; s > 0; s >>= 1) {
        if (tid < s) {
            tmp[tid] += tmp[tid + s];
        }
        barrier();
    }

    if (tid == 0) {
        outputBuffer[d_offset] = D_TYPE(tmp[0]); // Correct the output indexing
    }
}